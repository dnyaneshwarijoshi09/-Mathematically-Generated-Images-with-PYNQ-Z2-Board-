SOFTWARE CODE:

# 1. Install ipywidgets (needed for sliders in Colab)
!pip install ipywidgets
from google.colab import output
output.enable_custom_widget_manager()

# 2. Imports
import colorsys
from math import radians, cos, sin
from PIL import Image as IM, ImageDraw
from IPython.display import display
from ipywidgets import widgets, interact

# 3. Recursive tree drawing
def generate_tree(x_start, y_start, angle_deg, depth, depth_max, branch_angle, branch_length):
    if depth <= 0:
        return

    x_end = x_start + cos(radians(angle_deg)) * branch_length * depth
    y_end = y_start + sin(radians(angle_deg)) * branch_length * depth

    hue_val = float(depth) / depth_max
    r, g, b = colorsys.hsv_to_rgb(hue_val, 1.0, 1.0)
    R, G, B = int(r * 255), int(g * 255), int(b * 255)

    canvas.line([x_start, y_start, x_end, y_end], (R, G, B), width=max(1, depth))

    generate_tree(x_end, y_end, angle_deg - branch_angle, depth - 1, depth_max, branch_angle, branch_length)
    generate_tree(x_end, y_end, angle_deg + branch_angle, depth - 1, depth_max, branch_angle, branch_length)

# 4. Refresh function
def refresh_tree(depth_val, spread_val):
    branch_len = 7
    canvas.rectangle((0, 0, img_width, img_height), fill=(0, 0, 0))  # fixed coordinates
    generate_tree(img_width / 2, img_height * 0.9, -90, depth_val, depth_val, spread_val, branch_len)
    img.save("fractal_tree.png", "PNG")
    display(IM.open("fractal_tree.png"))

# 5. Setup canvas
img_width, img_height = 600, 480
img = IM.new("RGB", (img_width, img_height))
canvas = ImageDraw.Draw(img)

# 6. Interactive sliders in Colab
depth_slider = widgets.IntSlider(min=1, max=10, step=1, value=8, description="Depth")
spread_slider = widgets.IntSlider(min=0, max=45, step=1, value=15, description="Spread")
interact(refresh_tree, depth_val=depth_slider, spread_val=spread_slider)




HARDWARD CODE

import colorsys
import math
from PIL import Image as IM, ImageDraw
from IPython.display import display
from ipywidgets import widgets, interact

# Direct sine/cosine (replace FPGA CORDIC calls)
def sinPL(angle):
    return math.sin(angle)

def cosPL(angle):
    return math.cos(angle)

# Recursive function to draw tree
def drawTreePL(d, x1, y1, angle, depth, maxd, spread, length):
    if depth > 0:
        angleRad = math.radians(angle)
        
        # Adjust angle into valid range
        if angleRad < -(2*math.pi):
            angleRad += 2*math.pi
        elif angleRad > (2*math.pi):
            angleRad -= 2*math.pi
        
        if angleRad < -math.pi:
            cosAngle = cosPL(2*math.pi - abs(angleRad))
            sinAngle = sinPL((-angleRad) - math.pi)
        elif angleRad > math.pi:
            cosAngle = cosPL(2*math.pi - abs(angleRad))
            sinAngle = sinPL(math.pi - abs(angleRad))
        else:
            cosAngle = cosPL(angleRad)
            sinAngle = sinPL(angleRad)
        
        x2 = x1 + cosAngle * depth * length
        y2 = y1 + sinAngle * depth * length
        
        # Color by depth
        r, g, b = colorsys.hsv_to_rgb(float(depth) / maxd, 1.0, 1.0)
        R, G, B = int(255 * r), int(255 * g), int(255 * b)
        
        # Draw branch
        d.line([x1, y1, x2, y2], (R, G, B), depth)
        
        # Recursively draw sub-branches
        drawTreePL(d, x2, y2, angle - spread, depth - 1, maxd, spread, length)
        drawTreePL(d, x2, y2, angle + spread, depth - 1, maxd, spread, length)

# Update and display fractal
def updatePL(Depth, Spread):
    width = 600
    height = 480
    img = IM.new('RGB', (width, height), (0, 0, 0))
    d = ImageDraw.Draw(img)
    drawTreePL(d, width/2, height*0.9, -90, Depth, Depth, Spread, 7)
    display(img)

# Interactive sliders
maxDepth = widgets.IntSlider(min=1, max=10, step=1, value=8)
spread = widgets.IntSlider(min=0, max=45, step=1, value=15)
interact(updatePL, Depth=maxDepth, Spread=spread)
